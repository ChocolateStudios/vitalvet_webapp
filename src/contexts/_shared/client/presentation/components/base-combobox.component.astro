---
interface Option {
  id: string | number;
  name: string;
}

interface Props {
  id: string;
  name: string;
  label: string;
  options?: Option[];
  value?: string | number;
  class?: string;
  visible?: boolean;
  readonly?: boolean;
}

const {
  id,
  name, // Usado para el input oculto que guarda el valor real (ID)
  label,
  options = [], // Espera un array de objetos: [{ id, name }]
  value = "", // El ID de la opción seleccionada inicialmente
  class: className = "",
  visible = true,
  readonly = false,
} = Astro.props as Props;

// Busca el nombre a mostrar a partir del ID inicial proporcionado
const selectedOption = options.find((opt) => String(opt.id) === String(value));
const initialDisplayName = selectedOption ? selectedOption.name : "";
---

<div
  class:list={[
    "combobox-container relative w-full",
    className,
    { hidden: !visible },
  ]}
  data-options={JSON.stringify(options)}
>
  <!-- Input oculto que almacena el valor real (ID) para el formulario -->
  <input type="hidden" {name} id={`${id}-value`} value={value} />

  <!-- Input visible para la interacción del usuario -->
  <input
    type="text"
    role="combobox"
    aria-controls={`${id}-listbox`}
    aria-expanded="false"
    id={id}
    value={initialDisplayName}
    placeholder=""
    autocomplete="off"
    readonly={readonly}
    class:list={[
      "peer block w-full rounded-md border border-gray-300 px-3.5 pb-2.5 pt-5 text-base text-gray-900 pr-10",
      "focus:outline-none focus:ring-0 focus:border-2",
      { "bg-gray-100 focus:border-gray-300 cursor-not-allowed": readonly },
      { "bg-white focus:border-[#6faab5]": !readonly },
    ]}
  />

  <!-- Etiqueta flotante -->
  <label
    for={id}
    class:list={[
      "pointer-events-none absolute top-4 left-3.5 z-10 origin-[0] transform text-base text-gray-500 duration-300",
      "peer-placeholder-shown:translate-y-0 peer-placeholder-shown:scale-100",
      "peer-focus:-translate-y-3 peer-focus:scale-75",
      "peer-not-placeholder-shown:-translate-y-3 peer-not-placeholder-shown:scale-75",
      "peer-autofill:-translate-y-3 peer-autofill:scale-75",
      { "peer-focus:text-[#6faab5]": !readonly },
      { "-translate-y-3 scale-75": initialDisplayName }, // Asegura que la etiqueta esté arriba si hay valor inicial
    ]}
  >
    {label}
  </label>

  <!-- Icono de flecha para abrir/cerrar -->
  <div
    class="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-3.5 text-gray-500"
  >
    <svg
      xmlns="http://www.w3.org/2000/svg"
      class="h-5 w-5"
      viewBox="0 0 20 20"
      fill="currentColor"
    >
      <path
        fill-rule="evenodd"
        d="M10 3a1 1 0 01.707.293l3 3a1 1 0 01-1.414 1.414L10 5.414 7.707 7.707a1 1 0 01-1.414-1.414l3-3A1 1 0 0110 3zm-3.707 9.293a1 1 0 011.414 0L10 14.586l2.293-2.293a1 1 0 011.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z"
        clip-rule="evenodd"></path>
    </svg>
  </div>

  <!-- Lista desplegable de opciones -->
  <ul
    id={`${id}-listbox`}
    role="listbox"
    class="absolute z-20 mt-1 max-h-60 w-full overflow-auto rounded-md bg-white py-1 text-base shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none sm:text-sm hidden"
  >
    <!-- Las opciones se renderizarán aquí con JS -->
  </ul>

  <!-- Contenedor de errores -->
  <div id={`${id}-error-container`} class="mt-1 text-sm text-red-600 h-4"></div>
</div>

<script>
  interface Option {
    id: string | number;
    name: string;
  }

  class Combobox {
    container: HTMLElement;
    input: HTMLInputElement | null;
    hiddenInput: HTMLInputElement | null;
    listbox: HTMLUListElement | null;
    options: Option[];
    isReadonly: boolean | undefined;
    filteredOptions: Option[];
    highlightedIndex: number;
    isOpen: boolean;

    constructor(container: HTMLElement) {
      this.container = container;
      this.input = container.querySelector('input[role="combobox"]');
      this.hiddenInput = container.querySelector('input[type="hidden"]');
      this.listbox = container.querySelector('ul[role="listbox"]');
      this.options = JSON.parse(container.dataset.options || "[]");
      this.isReadonly = this.input?.hasAttribute("readonly");

      this.filteredOptions = [];
      this.highlightedIndex = -1;
      this.isOpen = false;

      this.addEventListeners();
    }

    addEventListeners() {
      if (this.isReadonly) return;

      if (this.input) {
        this.input.addEventListener("input", () => this.onInput());
        this.input.addEventListener("click", () => this.toggle());
        this.input.addEventListener("keydown", (e) => this.onKeydown(e));
      }
      this.container.addEventListener("focusout", (e) => this.onBlur(e));
    }

    filterOptions(query: string) {
      if (!query) {
        this.filteredOptions = this.options;
      } else {
        this.filteredOptions = this.options.filter((option) =>
          option.name.toLowerCase().includes(query.toLowerCase()),
        );
      }
      this.renderOptions();
    }

    renderOptions() {
      if (!this.listbox || !this.input) return;

      this.listbox.innerHTML = "";
      if (this.filteredOptions.length === 0) {
        this.listbox.innerHTML = `<li class="px-4 py-2 text-gray-500">No se encontraron resultados</li>`;
      } else {
        this.filteredOptions.forEach((option, index) => {
          const li = document.createElement("li");
          li.id = `${this.input?.id}-option-${index}`;
          li.textContent = option.name;
          li.dataset.value = option.id?.toString();
          li.setAttribute("role", "option");
          li.setAttribute("aria-selected", "false");
          li.className =
            "relative cursor-default select-none py-2 pl-3 pr-9 text-gray-900 hover:bg-[#6faab5] hover:text-white";
          li.addEventListener("mousedown", (e) => {
            // Mousedown para que se dispare antes del blur
            e.preventDefault();
            this.selectOption(option);
          });
          this.listbox?.appendChild(li);
        });
      }
      this.highlightOption(0);
    }

    selectOption(option: Option) {
      if (!this.input || !this.hiddenInput) return;

      this.input.value = option.name;
      this.hiddenInput.value = option.id.toString();
      this.close();
    }

    highlightOption(index: number) {
      if (!this.listbox || !this.input) return;

      this.listbox.querySelectorAll('li[role="option"]').forEach((li, i) => {
        if (i === index) {
          li.classList.add("bg-[#6faab5]", "text-white");
          li.setAttribute("aria-selected", "true");
          this.input?.setAttribute("aria-activedescendant", li.id);
          li.scrollIntoView({ block: "nearest" });
        } else {
          li.classList.remove("bg-[#6faab5]", "text-white");
          li.setAttribute("aria-selected", "false");
        }
      });
      this.highlightedIndex = index;
    }

    onInput() {
      if (!this.input) return;
      this.filterOptions(this.input.value);
      this.open();
    }

    onKeydown(e: KeyboardEvent) {
      switch (e.key) {
        case "ArrowDown":
          e.preventDefault();
          if (!this.isOpen) this.open();
          this.highlightOption(
            (this.highlightedIndex + 1) % this.filteredOptions.length,
          );
          break;
        case "ArrowUp":
          e.preventDefault();
          if (!this.isOpen) this.open();
          this.highlightOption(
            (this.highlightedIndex - 1 + this.filteredOptions.length) %
              this.filteredOptions.length,
          );
          break;
        case "Enter":
          e.preventDefault();
          if (this.isOpen && this.highlightedIndex >= 0) {
            this.selectOption(this.filteredOptions[this.highlightedIndex]);
          }
          break;
        case "Escape":
          this.close();
          break;
      }
    }

    onBlur(e: FocusEvent) {
      if (!this.input) return;
      if (!this.container.contains(e.relatedTarget as Node)) {
        this.close();
        // Si el texto no coincide con una opción, limpiar
        if (!this.input || !this.listbox || !this.hiddenInput) return;

        const currentOption = this.options.find(
          (opt) => opt.name === this.input?.value,
        );
        if (!currentOption) {
          this.input.value = "";
          this.hiddenInput.value = "";
        }
      }
    }

    toggle() {
      this.isOpen ? this.close() : this.open();
    }
    open() {
      if (!this.input || !this.listbox) return;
      this.filterOptions(this.input.value);
      this.listbox.classList.remove("hidden");
      this.input.setAttribute("aria-expanded", "true");
      this.isOpen = true;
    }
    close() {
      if (!this.input || !this.listbox) return;
      this.listbox.classList.add("hidden");
      this.input.setAttribute("aria-expanded", "false");
      this.input.removeAttribute("aria-activedescendant");
      this.highlightedIndex = -1;
      this.isOpen = false;
    }
  }

  document.querySelectorAll(".combobox-container").forEach((container) => {
    const htmlContainer = container as HTMLElement;

    // Para evitar doble inicialización con Astro View Transitions
    if (!htmlContainer.dataset.initialized) {
      htmlContainer.dataset.initialized = "true";
      new Combobox(htmlContainer);
    }
  });
</script>
