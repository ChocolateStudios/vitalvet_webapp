---
// Importamos los componentes de iconos que podríamos necesitar.
// Astro es lo suficientemente inteligente como para no incluir el código si no se usa.
import SearchIcon from "./icons/SearchIcon.astro";

/**
 * @typedef {object} Option - Define la estructura para las opciones de un combobox.
 * @property {string | number} id - El valor real (único) de la opción.
 * @property {string} name - El texto que se muestra al usuario.
 */
interface Option {
  id: string | number;
  name: string;
}

/**
 * @typedef {object} Action - Define una acción personalizada para el combobox.
 * @property {string} label - El texto de la acción (puede contener HTML).
 * @property {string} onClick - El código JS a ejecutar cuando se hace clic (ej. "miFuncion()").
 */
interface Action {
  label: string;
  onClick: string;
}

/**
 * @interface Props - La interfaz de props para el super-componente de input.
 * Es una unión de todas las props de los componentes originales.
 */
export interface Props {
  // --- PROPS COMUNES ---
  /** El tipo de input a renderizar. Puede ser un tipo de input HTML estándar
   * ('text', 'email', 'password', 'number', 'date', 'search') o un tipo personalizado
   * ('textarea', 'switch', 'combobox').
   * @default 'text' */
  type?: string;
  /** Identificador único para el input y sus elementos asociados (label, error). */
  id: string;
  /** El `name` del input, usado para la recolección de datos en formularios. */
  name: string;
  /** El texto a mostrar en la etiqueta flotante o estática. */
  label: string;
  /** El valor inicial del input. */
  value?: any;
  /** Mensaje de error a mostrar debajo del input. Si se provee, el input se marcará en rojo. */
  error?: string;
  /** Clases CSS adicionales para el contenedor principal del componente. */
  class?: string;
  /** Controla la visibilidad del componente. Si es `false`, se oculta con `display: none`.
   * @default true */
  visible?: boolean;
  /** Si es `true`, el input no se podrá editar.
   * @default false */
  readonly?: boolean;
  /** Texto a mostrar en un tooltip de ayuda al pasar el cursor sobre el input. */
  tooltip?: string;

  // --- PROPS PARA INPUTS DE TEXTO ---
  /** Atributo `autocomplete` para el input. */
  autocomplete?: string;

  // --- PROPS PARA TEXTAREA ---
  /** Número de filas para el `textarea`.
   * @default 3 */
  rows?: number;

  // --- PROPS PARA SWITCH ---
  /** El valor que representa el estado "activado" (checked).
   * @default true */
  trueValue?: any;
  /** El valor que representa el estado "desactivado" (unchecked).
   * @default false */
  falseValue?: any;
  /** Etiqueta a mostrar cuando el switch está en estado "activado". */
  trueLabel?: string;
  /** Etiqueta a mostrar cuando el switch está en estado "desactivado". */
  falseLabel?: string;
  /** Tooltip a mostrar cuando el switch está en estado "activado". */
  trueTooltip?: string;
  /** Tooltip a mostrar cuando el switch está en estado "desactivado". */
  falseTooltip?: string;

  // --- PROPS PARA COMBOBOX ---
  /** Array de objetos `Option` para poblar el combobox. */
  options?: Option[];
  /** Array de objetos `Action` para mostrar en el pie del combobox. */
  actions?: Action[];
}

// --- EXTRACCIÓN Y VALORES POR DEFECTO ---
const {
  // Comunes
  type = "text",
  id,
  name,
  label,
  value,
  error,
  class: className,
  visible = true,
  readonly = false,
  tooltip,
  // Textarea
  rows = 3,
  // Switch
  trueValue = true,
  falseValue = false,
  trueLabel,
  falseLabel,
  trueTooltip,
  falseTooltip,
  // Combobox
  options = [],
  actions = [],
  // Input
  autocomplete,
} = Astro.props as Props;

// --- LÓGICA PRE-RENDERIZADO ---

// Determina si hay slots de iconos (para inputs de texto)
const hasIconLeft = Astro.slots.has("icon-left");
const hasIconRight = Astro.slots.has("icon-right");

// Lógica específica para el Switch
const isChecked = value === trueValue;
const initialHiddenValue = isChecked ? trueValue : falseValue;
const isDynamicLabel = !!(trueLabel && falseLabel);
const initialLabelText = isDynamicLabel
  ? isChecked
    ? trueLabel
    : falseLabel
  : label;
const isDynamicTooltip = !!(trueTooltip && falseTooltip);
const initialTooltipText = isDynamicTooltip
  ? isChecked
    ? trueTooltip
    : falseTooltip
  : tooltip;

// Lógica específica para el Combobox
const selectedOption = options.find((opt) => String(opt.id) === String(value));
const initialDisplayName = selectedOption ? selectedOption.name : "";
---

<!-- RENDERIZADO CONDICIONAL BASADO EN EL 'type' -->

{/* --- TIPO: SWITCH --- */}
{type === "switch" && (
  <div class:list={["w-full group", className, { hidden: !visible }]}>
    <div class="flex items-center py-2.5 gap-3">
      <div class="flex items-center gap-2">
        <label
          for={id}
          id={`${id}-label`}
          class:list={[
            "text-base text-gray-900",
            readonly ? "cursor-not-allowed opacity-60" : "cursor-pointer",
          ]}
        >
          {initialLabelText}
        </label>
        {initialTooltipText && (
          <div class="relative flex items-center group/tooltip cursor-help">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              class="h-4 w-4 text-gray-400"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
              stroke-width="2"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
              ></path>
            </svg>
            <div
              id={`${id}-tooltip-text`}
              class="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 w-max max-w-xs p-2 text-sm text-white bg-gray-800 rounded-md shadow-lg opacity-0 group-hover/tooltip:opacity-100 transition-opacity pointer-events-none z-10"
            >
              {initialTooltipText}
            </div>
          </div>
        )}
      </div>

      <div class="flex items-center">
        <input
          type="hidden"
          {name}
          id={`${id}-value`}
          value={String(initialHiddenValue)}
        />
        <label
          for={id}
          class:list={[
            "relative inline-flex items-center",
            readonly ? "cursor-not-allowed" : "cursor-pointer",
          ]}
        >
          <input
            type="checkbox"
            {id}
            checked={isChecked}
            disabled={readonly}
            class="sr-only peer"
            data-true-value={String(trueValue)}
            data-false-value={String(falseValue)}
            data-true-label={trueLabel}
            data-false-label={falseLabel}
            data-true-tooltip={trueTooltip}
            data-false-tooltip={falseTooltip}
          />
          <div
            class:list={[
              "w-11 h-6 bg-gray-200 rounded-full",
              "peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-offset-2 peer-focus:ring-[#6faab5]",
              "peer-checked:after:translate-x-full peer-checked:after:border-white",
              "after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all",
              { "peer-checked:bg-[#6faab5]": !readonly },
              { "opacity-60": readonly },
            ]}
          ></div>
        </label>
      </div>
    </div>
    <div id={`${id}-error-container`} class="mt-1 text-sm text-red-600 h-4">
      {error}
    </div>
  </div>
)}

{/* --- TIPO: TEXTAREA --- */}
{type === "textarea" && (
  <div class:list={["relative w-full group", className, { hidden: !visible }]}>
    <textarea
      {id}
      {name}
      {rows}
      {readonly}
      placeholder=" "
      class:list={[
        "peer block w-full rounded-md border border-gray-300 px-3.5 pb-2.5 pt-5 text-base text-gray-900",
        "focus:outline-none focus:ring-0 focus:border-2",
        { "bg-gray-100 focus:border-gray-300 cursor-not-allowed": readonly },
        { "bg-white focus:border-[#6faab5]": !readonly },
        { "border-red-600 focus:border-red-600": error },
      ]}
    >{value}</textarea>
    <label
      for={id}
      class:list={[
        "pointer-events-none absolute top-4 left-3.5 z-10 origin-[0] transform text-base text-gray-500 duration-300",
        "peer-placeholder-shown:translate-y-0 peer-placeholder-shown:scale-100",
        "peer-focus:-translate-y-3 peer-focus:scale-75",
        "peer-not-placeholder-shown:-translate-y-3 peer-not-placeholder-shown:scale-75",
        "peer-autofill:-translate-y-3 peer-autofill:scale-75",
        { "peer-focus:text-[#6faab5]": !readonly },
        { "text-red-600 peer-focus:text-red-600": error },
      ]}
    >
      {label}
    </label>
    <div id={`${id}-error-container`} class="mt-1 text-sm text-red-600 h-4">
      {error}
    </div>
  </div>
)}

{/* --- TIPO: COMBOBOX --- */}
{type === "combobox" && (
  <div
    class:list={[
      "combobox-container relative w-full",
      className,
      { hidden: !visible },
    ]}
    data-options={JSON.stringify(options)}
  >
    <input type="hidden" {name} id={`${id}-value`} value={value} />
    <input
      type="text"
      role="combobox"
      aria-controls={`${id}-listbox`}
      aria-expanded="false"
      {id}
      value={initialDisplayName}
      placeholder=" "
      autocomplete="off"
      readonly={readonly}
      class:list={[
        "peer block w-full rounded-md border border-gray-300 px-3.5 pb-2.5 pt-5 text-base text-gray-900 pr-10",
        "focus:outline-none focus:ring-0 focus:border-2",
        { "bg-gray-100 focus:border-gray-300 cursor-not-allowed": readonly },
        { "bg-white focus:border-[#6faab5]": !readonly },
        { "border-red-600 focus:border-red-600": error },
      ]}
    />
    <label
      for={id}
      class:list={[
        "pointer-events-none absolute top-4 left-3.5 z-10 origin-[0] transform text-base text-gray-500 duration-300",
        "peer-placeholder-shown:translate-y-0 peer-placeholder-shown:scale-100",
        "peer-focus:-translate-y-3 peer-focus:scale-75",
        "peer-not-placeholder-shown:-translate-y-3 peer-not-placeholder-shown:scale-75",
        "peer-autofill:-translate-y-3 peer-autofill:scale-75",
        { "peer-focus:text-[#6faab5]": !readonly },
        { "-translate-y-3 scale-75": initialDisplayName },
        { "text-red-600 peer-focus:text-red-600": error },
      ]}
    >
      {label}
    </label>
    <div
      class="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-3.5 text-gray-500"
    >
      <svg
        xmlns="http://www.w3.org/2000/svg"
        class="h-5 w-5"
        viewBox="0 0 20 20"
        fill="currentColor"
      >
        <path
          fill-rule="evenodd"
          d="M10 3a1 1 0 01.707.293l3 3a1 1 0 01-1.414 1.414L10 5.414 7.707 7.707a1 1 0 01-1.414-1.414l3-3A1 1 0 0110 3zm-3.707 9.293a1 1 0 011.414 0L10 14.586l2.293-2.293a1 1 0 011.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z"
          clip-rule="evenodd"></path>
      </svg>
    </div>
    <div
      id={`${id}-listbox-wrapper`}
      class="absolute z-20 mt-1 w-full rounded-md bg-white text-base shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none hidden"
    >
      <ul
        id={`${id}-listbox`}
        role="listbox"
        class="max-h-60 w-full overflow-auto py-1 sm:text-sm"
      ></ul>
      {actions.length > 0 && (
        <div class="border-t border-gray-200 p-1">
          {actions.map((action) => (
            <button
              type="button"
              class="relative w-full text-left cursor-pointer select-none rounded-md py-2 px-3 text-sm text-gray-700 hover:bg-[#6faab5] hover:text-white"
              onclick={action.onClick}
              set:html={action.label}
            ></button>
          ))}
        </div>
      )}
    </div>
    <div id={`${id}-error-container`} class="mt-1 text-sm text-red-600 h-4">
      {error}
    </div>
  </div>
)}

{/* --- TIPO: INPUT ESTÁNDAR (text, password, email, number, search, etc.) --- */}
{/* Este es el caso por defecto si 'type' no es uno de los personalizados de arriba. */}
{!["switch", "textarea", "combobox"].includes(type) && (
  <div
    class:list={["relative w-full group", className, { hidden: !visible }]}
  >
    {/* El icono de búsqueda se muestra solo si type es 'search' */}
    {type === "search" && (
      <div class="pointer-events-none absolute inset-y-0 left-0 flex items-center pl-3.5 text-gray-500">
        <SearchIcon />
      </div>
    )}
    {/* Slots para iconos personalizados */}
    {hasIconLeft && (
      <div class="pointer-events-none absolute inset-y-0 left-0 flex items-center pl-3.5 text-gray-500">
        <slot name="icon-left" />
      </div>
    )}
    {hasIconRight && (
      <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-3.5 text-gray-500">
        <slot name="icon-right" />
      </div>
    )}

    <input
      {id}
      {name}
      type={type as "text" | "email" | "password" | "number" | "date" | "search"}
      {autocomplete}
      {value}
      {readonly}
      placeholder=" "
      class:list={[
        "peer block w-full rounded-md border border-gray-300 px-3.5 pb-2.5 pt-5 text-base text-gray-900",
        "focus:outline-none focus:ring-0 focus:border-2",
        { "pl-10": hasIconLeft || type === "search" },
        { "pr-10": hasIconRight },
        { "bg-gray-100 focus:border-gray-300 cursor-not-allowed": readonly },
        { "bg-white focus:border-[#6faab5]": !readonly },
        { "border-red-600 focus:border-red-600": error },
      ]}
    />
    <label
      for={id}
      class:list={[
        "pointer-events-none absolute top-4 z-10 origin-[0] transform text-base text-gray-500 duration-300",
        "peer-placeholder-shown:translate-y-0 peer-placeholder-shown:scale-100",
        "peer-focus:-translate-y-3 peer-not-placeholder-shown:scale-75",
        "peer-not-placeholder-shown:-translate-y-3 peer-not-placeholder-shown:scale-75",
        "peer-autofill:scale-75 peer-autofill:-translate-y-3",
        { "peer-focus:text-[#6faab5]": !readonly },
        { "left-10": hasIconLeft || type === "search" },
        { "left-3.5": !hasIconLeft && type !== "search" },
        { "text-red-600 peer-focus:text-red-600": error },
      ]}
    >
      {label}
    </label>

    <div id={`${id}-error-container`} class="mt-1 text-sm text-red-600 h-4">
      {error}
    </div>

    {tooltip && (
      <div
        role="tooltip"
        class="absolute z-20 invisible group-hover:visible inline-block px-3 py-2 text-sm font-medium text-white transition-opacity duration-300 bg-gray-900 rounded-lg shadow-sm opacity-0 group-hover:opacity-100 bottom-full mb-2 left-1/2 -translate-x-1/2 w-max max-w-xs pointer-events-none"
      >
        {tooltip}
        <div class="tooltip-arrow absolute top-full left-1/2 -translate-x-1/2 w-0 h-0 border-x-8 border-x-transparent border-t-8 border-t-gray-900">
        </div>
      </div>
    )}
  </div>
)}

<script>
  // --- LÓGICA DE CLIENTE ---
  // Este script se envía al cliente, pero las funciones solo se ejecutarán
  // si encuentran los elementos correspondientes en el DOM.

  // --- DEFINICIÓN DE LA CLASE COMBOBOX ---
  class Combobox {
    container: HTMLElement;
    input: HTMLInputElement | null;
    listboxWrapper: HTMLDivElement | null;
    hiddenInput: HTMLInputElement | null;
    listbox: HTMLUListElement | null;
    options: { id: string | number; name: string }[];
    isReadonly: boolean | undefined;
    filteredOptions: { id: string | number; name: string }[];
    highlightedIndex: number;
    isOpen: boolean;

    constructor(container: HTMLElement) {
      this.container = container;
      this.input = container.querySelector('input[role="combobox"]');
      this.listboxWrapper = container.querySelector(
        `#${this.input?.id}-listbox-wrapper`,
      );
      this.hiddenInput = container.querySelector('input[type="hidden"]');
      this.listbox = container.querySelector('ul[role="listbox"]');
      this.options = JSON.parse(container.dataset.options || "[]");
      this.isReadonly = this.input?.hasAttribute("readonly");
      this.filteredOptions = [];
      this.highlightedIndex = -1;
      this.isOpen = false;
      this.addEventListeners();
      if (this.input) window.comboboxInstances[this.input.id] = this;
    }

    addEventListeners() {
      if (this.isReadonly || !this.input) return;
      this.input.addEventListener("input", () => this.onInput());
      this.input.addEventListener("click", () => this.toggle());
      this.input.addEventListener("keydown", (e) => this.onKeydown(e));
      this.container.addEventListener("focusout", (e) => this.onBlur(e));
    }

    filterOptions(query: string) {
      this.filteredOptions = query
        ? this.options.filter((opt) =>
            opt.name.toLowerCase().includes(query.toLowerCase()),
          )
        : this.options;
      this.renderOptions();
    }

    renderOptions() {
      if (!this.listbox || !this.input) return;
      this.listbox.innerHTML =
        this.filteredOptions.length === 0
          ? `<li class="px-4 py-2 text-gray-500">No se encontraron resultados</li>`
          : "";
      this.filteredOptions.forEach((option, index) => {
        const li = document.createElement("li");
        li.id = `${this.input?.id}-option-${index}`;
        li.textContent = option.name;
        li.dataset.value = option.id?.toString();
        li.setAttribute("role", "option");
        li.setAttribute("aria-selected", "false");
        li.className =
          "relative cursor-default select-none py-2 pl-3 pr-9 text-gray-900 hover:bg-[#6faab5] hover:text-white";
        li.addEventListener("mousedown", (e) => {
          e.preventDefault();
          this.selectOption(option);
        });
        this.listbox?.appendChild(li);
      });
      this.highlightOption(0);
    }

    selectOption(option: { id: string | number; name: string }) {
      if (!this.input || !this.hiddenInput) return;
      this.input.value = option.name;
      this.hiddenInput.value = option.id.toString();
      this.hiddenInput.dispatchEvent(new Event("change", { bubbles: true }));
      this.close();
    }
    
    addOptionAndSelect(newOption: any) {
      if (!this.input || !this.hiddenInput) return;
      const exists = this.options.some(opt => String(opt.id) === String(newOption.id));
      if (!exists) this.options.push(newOption);
      this.input.value = newOption.name;
      this.hiddenInput.value = newOption.id.toString();
      this.hiddenInput.dispatchEvent(new Event('change', { bubbles: true }));
      this.close();
  }

    highlightOption(index: number) {
      if (!this.listbox || !this.input) return;
      this.listbox.querySelectorAll('li[role="option"]').forEach((li, i) => {
        if (i === index) {
          li.classList.add("bg-[#6faab5]", "text-white");
          li.setAttribute("aria-selected", "true");
          this.input?.setAttribute("aria-activedescendant", li.id);
          li.scrollIntoView({ block: "nearest" });
        } else {
          li.classList.remove("bg-[#6faab5]", "text-white");
          li.setAttribute("aria-selected", "false");
        }
      });
      this.highlightedIndex = index;
    }

    onInput() {
      if (!this.input) return;
      this.filterOptions(this.input.value);
      this.open();
    }

    onKeydown(e: KeyboardEvent) {
      switch (e.key) {
        case "ArrowDown":
          e.preventDefault();
          if (!this.isOpen) this.open();
          this.highlightOption(
            (this.highlightedIndex + 1) % this.filteredOptions.length,
          );
          break;
        case "ArrowUp":
          e.preventDefault();
          if (!this.isOpen) this.open();
          this.highlightOption(
            (this.highlightedIndex - 1 + this.filteredOptions.length) %
              this.filteredOptions.length,
          );
          break;
        case "Enter":
          e.preventDefault();
          if (this.isOpen && this.highlightedIndex >= 0) {
            this.selectOption(this.filteredOptions[this.highlightedIndex]);
          }
          break;
        case "Escape":
          this.close();
          break;
      }
    }

    onBlur(e: FocusEvent) {
      if (
        !this.input ||
        this.container.contains(e.relatedTarget as Node)
      )
        return;
      this.close();
      const currentOption = this.options.find(
        (opt) => opt.name === this.input?.value,
      );
      if (!currentOption && this.hiddenInput) {
        this.input.value = "";
        this.hiddenInput.value = "";
      }
    }

    toggle() {
      this.isOpen ? this.close() : this.open();
    }
    open() {
      if (!this.input || !this.listboxWrapper) return;
      this.filterOptions(this.input.value);
      this.listboxWrapper.classList.remove("hidden");
      this.input.setAttribute("aria-expanded", "true");
      this.isOpen = true;
    }
    close() {
      if (!this.input || !this.listboxWrapper) return;
      this.listboxWrapper.classList.add("hidden");
      this.input.setAttribute("aria-expanded", "false");
      this.input.removeAttribute("aria-activedescendant");
      this.highlightedIndex = -1;
      this.isOpen = false;
    }
  }

  // Declara una propiedad global para las instancias de Combobox.
  declare global {
    interface Window {
      comboboxInstances: { [key: string]: Combobox };
    }
  }
  window.comboboxInstances = window.comboboxInstances || {};

  // --- LÓGICA PARA EL SWITCH ---
  function initializeSwitches() {
    document
      .querySelectorAll('input[type="checkbox"].peer:not([data-initialized])')
      .forEach((switchEl) => {
        const htmlSwitchEl = switchEl as HTMLInputElement;
        htmlSwitchEl.dataset.initialized = "true";

        const hiddenInput = document.getElementById(
          `${htmlSwitchEl.id}-value`,
        ) as HTMLInputElement | null;
        const labelEl = document.getElementById(
          `${htmlSwitchEl.id}-label`,
        ) as HTMLLabelElement | null;
        const tooltipTextEl = document.getElementById(
          `${htmlSwitchEl.id}-tooltip-text`,
        ) as HTMLDivElement | null;

        if (!hiddenInput) return;

        htmlSwitchEl.addEventListener("change", () => {
          hiddenInput.value = htmlSwitchEl.checked
            ? htmlSwitchEl.dataset.trueValue!
            : htmlSwitchEl.dataset.falseValue!;

          const trueLabel = htmlSwitchEl.dataset.trueLabel;
          const falseLabel = htmlSwitchEl.dataset.falseLabel;
          if (labelEl && trueLabel && falseLabel) {
            labelEl.textContent = htmlSwitchEl.checked ? trueLabel : falseLabel;
          }

          const trueTooltip = htmlSwitchEl.dataset.trueTooltip;
          const falseTooltip = htmlSwitchEl.dataset.falseTooltip;
          if (tooltipTextEl && trueTooltip && falseTooltip) {
            tooltipTextEl.textContent = htmlSwitchEl.checked
              ? trueTooltip
              : falseTooltip;
          }
        });
      });
  }

  // --- LÓGICA PARA EL COMBOBOX ---
  function initializeComboboxes() {
    const containers = document.querySelectorAll(".combobox-container");
    if (containers.length === 0) return; // No hacer nada si no hay comboboxes

    containers.forEach((container) => {
      const htmlContainer = container as HTMLElement;
      if (!htmlContainer.dataset.initialized) {
        htmlContainer.dataset.initialized = "true";
        new Combobox(htmlContainer);
      }
    });
  }

  // --- INICIALIZADOR PRINCIPAL ---
  // Se ejecuta en cada carga de página (compatible con View Transitions de Astro).
  function initializeAllInputs() {
    initializeSwitches();
    initializeComboboxes();
  }

  document.addEventListener("astro:page-load", initializeAllInputs);
</script>